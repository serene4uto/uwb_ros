# import rclpy
# from rclpy.node import Node
# from uwb_interfaces.msg import UwbRange
# from nav_msgs.msg import Odometry
# from geometry_msgs.msg import PoseWithCovariance, TwistWithCovariance, PointStamped

# import numpy as np
# from scipy.optimize import least_squares

# MAX_NUM_ANCHORS = 4

# def multilateration(distances):
#     # Anchor positions
#     anchors = np.array([
#         [0.0, 0.0, 0.93],
#         [1.683, 0.0, 1.75],
#         [1.683, 1.25, 2.065],
#         [0.0, 1.25, 1.33]
#     ])

#     # Function to minimize
#     def residuals(variables):
#         x, y, z = variables
#         res = [
#             np.sqrt((x - anchors[i][0])**2 + (y - anchors[i][1])**2 + (z - anchors[i][2])**2) - distances[i]
#             for i in range(MAX_NUM_ANCHORS)
#         ]
#         return res

#     # Initial guess
#     initial_guess = [1.0, 1.0, 1.0]

#     # Solve the system of equations
#     solution = least_squares(residuals, initial_guess)
#     position = solution.x

#     return position

# class UwbTagLocalizer(Node):
#     def __init__(self):
#         super().__init__('uwb_tag_localizer')
#         self.get_logger().info('UwbTagLocalizer node started')

#         self.uwb_range_sub = self.create_subscription(
#             UwbRange,
#             'uros_esp32_uwb_tag_range',
#             self.uwb_range_callback,
#             10
#         )

#         self.uwb_point_raw_pub = self.create_publisher(
#             PointStamped,
#             'uwb_tag_point/raw',
#             10
#         )

#         self.uwb_point_ekf_pub = self.create_publisher(
#             PointStamped,
#             'uwb_tag_point/ekf',
#             10
#         )

#         self.uwb_odom_pub = self.create_publisher(
#             Odometry,
#             'uwb_tag_odom',
#             10
#         )

#         # EKF state and covariance initialization
#         self.state = np.zeros(6)  # [x, y, z, vx, vy, vz]
#         self.covariance = np.eye(6) * 0.1
#         self.process_noise_cov = np.eye(6) * 0.1
#         self.measurement_noise_cov = np.eye(3) * 0.1

#         # Timer to call the prediction step at a fixed rate
#         self.timer_period = 0.1  # seconds
#         self.last_update_time = self.get_clock().now()
#         self.timer = self.create_timer(self.timer_period, self.timer_callback)

#     def motion_model(self, state, dt):
#         F = np.eye(6)
#         F[0, 3] = dt
#         F[1, 4] = dt
#         F[2, 5] = dt
#         return F @ state

#     def motion_jacobian(self, dt):
#         F = np.eye(6)
#         F[0, 3] = dt
#         F[1, 4] = dt
#         F[2, 5] = dt
#         return F

#     def observation_model(self, state):
#         return state[:3]

#     def observation_jacobian(self):
#         H = np.zeros((3, 6))
#         H[0, 0] = 1
#         H[1, 1] = 1
#         H[2, 2] = 1
#         return H

#     def ekf_predict(self, dt):
#         # Predict state
#         self.state = self.motion_model(self.state, dt)
#         # Predict covariance
#         F = self.motion_jacobian(dt)
#         self.covariance = F @ self.covariance @ F.T + self.process_noise_cov

#     def ekf_update(self, measurement):
#         # Compute innovation
#         y = measurement - self.observation_model(self.state)
#         # Compute innovation covariance
#         H = self.observation_jacobian()
#         S = H @ self.covariance @ H.T + self.measurement_noise_cov
#         # Compute Kalman gain
#         K = self.covariance @ H.T @ np.linalg.inv(S)
#         # Update state
#         self.state = self.state + K @ y
#         # Update covariance
#         I = np.eye(len(self.state))
#         self.covariance = (I - K @ H) @ self.covariance


#     def uwb_range_callback(self, msg):
#         # self.get_logger().info(f"Received UwbRange message: {msg}")

#         distances = []
#         try:
#             for anchor_id in range(1, MAX_NUM_ANCHORS + 1):
#                 index = msg.anchor_ids.index(anchor_id)
#                 distances.append(msg.range_values[index])
#         except ValueError as e:
#             self.get_logger().error(f"Anchor ID not found: {e}")
#             return

#         estimated_position = multilateration(distances)

#         # self.get_logger().info(f"Estimated position: {estimated_position}")

#         # EKF update step
#         self.ekf_update(estimated_position)

#         point_msg = PointStamped()
#         point_msg.header.stamp  = self.get_clock().now().to_msg()
#         point_msg.header.frame_id = 'uwb_tag_link'
#         point_msg.point.x = estimated_position[0]
#         point_msg.point.y = estimated_position[1]
#         point_msg.point.z = estimated_position[2]
#         self.uwb_point_raw_pub.publish(point_msg)


#         # Publish the updated state as PointStamped message
#         point_msg = PointStamped()
#         point_msg.header.stamp = self.get_clock().now().to_msg()
#         point_msg.header.frame_id = 'uwb_tag_link'
#         point_msg.point.x = self.state[0]
#         point_msg.point.y = self.state[1]
#         point_msg.point.z = self.state[2]
#         self.uwb_point_ekf_pub.publish(point_msg)


#         # Publish the updated state as Odometry message
#         # odom_msg = Odometry()
#         # odom_msg.header.stamp = self.get_clock().now().to_msg()
#         # odom_msg.pose.pose.position.x = self.state[0]
#         # odom_msg.pose.pose.position.y = self.state[1]
#         # odom_msg.pose.pose.position.z = self.state[2]
#         # self.uwb_odom_pub.publish(odom_msg)


#     def timer_callback(self):
#         # EKF prediction step
#         current_time = self.get_clock().now()
#         dt = (current_time - self.last_update_time).nanoseconds / 1e9  # convert to seconds
#         self.last_update_time = current_time
#         self.ekf_predict(dt)


# def main(args=None):
#     rclpy.init(args=args)
#     uwb_tag_localizer_node = UwbTagLocalizer()

#     rclpy.spin(uwb_tag_localizer_node)
#     uwb_tag_localizer_node.destroy_node()
#     rclpy.shutdown()

# if __name__ == '__main__':
#     main()
